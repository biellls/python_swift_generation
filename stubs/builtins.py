from typing import overload, Union, SupportsInt, Text, Sequence, Tuple, Optional, Any


# noinspection PyPropertyDefinition,PyPep8Naming,PyShadowingBuiltins
class int:
    # SWIFT_WRAPPER.int: ExpressibleByIntegerLiteral
    # @not_overload
    # def __init__(self, x: Union[Text, bytes, SupportsInt] = ...) -> None: ...
    # @not_overload
    def __init__(self, x: Union[Text, bytes, bytearray], base: 'int'): ...

    @property
    def real(self) -> 'int': ...
    @property
    def imag(self) -> 'int': ...
    @property
    def numerator(self) -> 'int': ...
    @property
    def denominator(self) -> 'int': ...
    def conjugate(self) -> 'int': ...

    def bit_length(self) -> 'int': ...
    def to_bytes(self, length: 'int', byteorder: str, *, signed: bool = False) -> bytes: ...
    @classmethod
    def from_bytes(cls, bytes: Sequence['int'], byteorder: str, *, signed: bool = False) -> 'int': ...

    def __add__(self, x: 'int') -> 'int': ...
    def __sub__(self, x: 'int') -> 'int': ...
    def __mul__(self, x: 'int') -> 'int': ...
    def __floordiv__(self, x: 'int') -> 'int': ...
    def __truediv__(self, x: 'int') -> float: ...
    def __mod__(self, x: 'int') -> 'int': ...
    def __divmod__(self, x: 'int') -> Tuple['int', 'int']: ...
    def __radd__(self, x: 'int') -> 'int': ...
    def __rsub__(self, x: 'int') -> 'int': ...
    def __rmul__(self, x: 'int') -> 'int': ...
    def __rfloordiv__(self, x: 'int') -> 'int': ...
    def __rtruediv__(self, x: 'int') -> float: ...
    def __rmod__(self, x: 'int') -> 'int': ...
    def __rdivmod__(self, x: 'int') -> Tuple['int', 'int']: ...
    def __pow__(self, __x: 'int', __modulo: Optional['int'] = ...) -> Any: ...  # Return type can be int or float, depending on x.
    def __rpow__(self, x: 'int') -> Any: ...
    def __and__(self, n: 'int') -> 'int': ...
    def __or__(self, n: 'int') -> 'int': ...
    def __xor__(self, n: 'int') -> 'int': ...
    def __lshift__(self, n: 'int') -> 'int': ...
    def __rshift__(self, n: 'int') -> 'int': ...
    def __rand__(self, n: 'int') -> 'int': ...
    def __ror__(self, n: 'int') -> 'int': ...
    def __rxor__(self, n: 'int') -> 'int': ...
    def __rlshift__(self, n: 'int') -> 'int': ...
    def __rrshift__(self, n: 'int') -> 'int': ...
    def __neg__(self) -> 'int': ...
    def __pos__(self) -> 'int': ...
    def __invert__(self) -> 'int': ...
    def __trunc__(self) -> 'int': ...
    def __round__(self, ndigits: Optional['int'] = ...) -> 'int': ...
    def __getnewargs__(self) -> Tuple['int']: ...

    def __eq__(self, x: object) -> bool: ...
    def __ne__(self, x: object) -> bool: ...
    def __lt__(self, x: 'int') -> bool: ...
    def __le__(self, x: 'int') -> bool: ...
    def __gt__(self, x: 'int') -> bool: ...
    def __ge__(self, x: 'int') -> bool: ...

    def __str__(self) -> str: ...
    def __float__(self) -> float: ...
    def __int__(self) -> 'int': ...
    def __abs__(self) -> 'int': ...
    def __hash__(self) -> 'int': ...
    def __bool__(self) -> bool: ...
    def __index__(self) -> 'int': ...


# noinspection PyPep8Naming
class float:
    # SWIFT_WRAPPER.float: ExpressibleByIntegerLiteral, ExpressibleByFloatLiteral
    # def __init__(self, x: Union[SupportsFloat, Text, bytes, bytearray] = ...) -> None: ...
    def __init__(self, x: Union[Text, bytes, bytearray]): ...
    def as_integer_ratio(self) -> Tuple[int, int]: ...
    def hex(self) -> str: ...
    def is_integer(self) -> bool: ...
    @classmethod
    def fromhex(cls, s: str) -> 'float': ...

    @property
    def real(self) -> 'float': ...
    @property
    def imag(self) -> 'float': ...
    def conjugate(self) -> 'float': ...

    def __add__(self, x: 'float') -> 'float': ...
    def __sub__(self, x: 'float') -> 'float': ...
    def __mul__(self, x: 'float') -> 'float': ...
    def __floordiv__(self, x: 'float') -> 'float': ...
    def __truediv__(self, x: 'float') -> 'float': ...
    def __mod__(self, x: 'float') -> 'float': ...
    def __divmod__(self, x: 'float') -> Tuple['float', 'float']: ...
    def __pow__(self, x: 'float') -> 'float': ...  # In Python 3, returns complex if self is negative and x is not whole
    def __radd__(self, x: 'float') -> 'float': ...
    def __rsub__(self, x: 'float') -> 'float': ...
    def __rmul__(self, x: 'float') -> 'float': ...
    def __rfloordiv__(self, x: 'float') -> 'float': ...
    def __rtruediv__(self, x: 'float') -> 'float': ...
    def __rmod__(self, x: 'float') -> 'float': ...
    def __rdivmod__(self, x: 'float') -> Tuple['float', 'float']: ...
    def __rpow__(self, x: 'float') -> 'float': ...
    def __getnewargs__(self) -> Tuple['float']: ...
    def __trunc__(self) -> int: ...
    # @overload
    # def __round__(self, ndigits: None = ...) -> int: ...
    # @overload
    # def __round__(self, ndigits: int) -> 'float': ...

    def __eq__(self, x: object) -> bool: ...
    def __ne__(self, x: object) -> bool: ...
    def __lt__(self, x: 'float') -> bool: ...
    def __le__(self, x: 'float') -> bool: ...
    def __gt__(self, x: 'float') -> bool: ...
    def __ge__(self, x: 'float') -> bool: ...
    def __neg__(self) -> 'float': ...
    def __pos__(self) -> 'float': ...

    def __str__(self) -> str: ...
    def __int__(self) -> int: ...
    def __float__(self) -> 'float': ...
    def __abs__(self) -> 'float': ...
    def __hash__(self) -> int: ...
    def __bool__(self) -> bool: ...
