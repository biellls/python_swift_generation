from typing import overload, Union, SupportsInt, Text, Sequence, Tuple, Optional, Any, Iterator, Generic, TypeVar


# noinspection PyPropertyDefinition,PyPep8Naming,PyShadowingBuiltins
class int:
    # SWIFT_WRAPPER.int: ExpressibleByIntegerLiteral
    # SWIFT_WRAPPER.int: CPython
    # @not_overload
    # def __init__(self, x: Union[Text, bytes, SupportsInt] = ...) -> None: ...
    # @not_overload
    # def __init__(self, x: Union[Text, bytes, bytearray], base: 'int'): ...

    @property
    def real(self) -> 'int': ...
    @property
    def imag(self) -> 'int': ...
    @property
    def numerator(self) -> 'int': ...
    @property
    def denominator(self) -> 'int': ...
    def conjugate(self) -> 'int': ...

    def bit_length(self) -> 'int': ...
    # def to_bytes(self, length: 'int', byteorder: str, *, signed: bool = False) -> bytes: ...
    # @classmethod
    # def from_bytes(cls, bytes: Sequence['int'], byteorder: str, *, signed: bool = False) -> 'int': ...

    def __add__(self, x: 'int') -> 'int': ...
    def __sub__(self, x: 'int') -> 'int': ...
    def __mul__(self, x: 'int') -> 'int': ...
    def __floordiv__(self, x: 'int') -> 'int': ...
    def __truediv__(self, x: 'int') -> 'float': ...
    def __mod__(self, x: 'int') -> 'int': ...
    # def __divmod__(self, x: 'int') -> Tuple['int', 'int']: ...
    def __radd__(self, x: 'int') -> 'int': ...
    def __rsub__(self, x: 'int') -> 'int': ...
    def __rmul__(self, x: 'int') -> 'int': ...
    def __rfloordiv__(self, x: 'int') -> 'int': ...
    def __rtruediv__(self, x: 'int') -> 'float': ...
    def __rmod__(self, x: 'int') -> 'int': ...
    # def __rdivmod__(self, x: 'int') -> Tuple['int', 'int']: ...
    def __pow__(self, __x: 'int', __modulo: Optional['int'] = ...) -> Any: ...  # Return type can be int or float, depending on x.
    def __rpow__(self, x: 'int') -> Any: ...
    def __and__(self, n: 'int') -> 'int': ...
    def __or__(self, n: 'int') -> 'int': ...
    def __xor__(self, n: 'int') -> 'int': ...
    def __lshift__(self, n: 'int') -> 'int': ...
    def __rshift__(self, n: 'int') -> 'int': ...
    def __rand__(self, n: 'int') -> 'int': ...
    def __ror__(self, n: 'int') -> 'int': ...
    def __rxor__(self, n: 'int') -> 'int': ...
    def __rlshift__(self, n: 'int') -> 'int': ...
    def __rrshift__(self, n: 'int') -> 'int': ...
    def __neg__(self) -> 'int': ...
    def __pos__(self) -> 'int': ...
    def __invert__(self) -> 'int': ...
    def __trunc__(self) -> 'int': ...
    def __round__(self, ndigits: Optional['int'] = ...) -> 'int': ...
    # def __getnewargs__(self) -> Tuple['int']: ...

    def __eq__(self, x: object) -> bool: ...
    def __ne__(self, x: object) -> bool: ...
    def __lt__(self, x: 'int') -> bool: ...
    def __le__(self, x: 'int') -> bool: ...
    def __gt__(self, x: 'int') -> bool: ...
    def __ge__(self, x: 'int') -> bool: ...

    def __str__(self) -> 'str': ...
    def __float__(self) -> 'float': ...
    def __int__(self) -> 'int': ...
    def __abs__(self) -> 'int': ...
    def __hash__(self) -> 'int': ...
    def __bool__(self) -> bool: ...
    def __index__(self) -> 'int': ...


# noinspection PyPep8Naming,PyShadowingBuiltins
class float:
    # SWIFT_WRAPPER.float: ExpressibleByIntegerLiteral, ExpressibleByFloatLiteral
    # SWIFT_WRAPPER.float: CPython
    # def __init__(self, x: Union[SupportsFloat, Text, bytes, bytearray] = ...) -> None: ...
    # def __init__(self, x: Union[Text, bytes, bytearray]): ...
    # def as_integer_ratio(self) -> Tuple[int, int]: ...
    def hex(self) -> 'str': ...
    def is_integer(self) -> bool: ...
    @classmethod
    def fromhex(cls, s: 'str') -> 'float': ...

    @property
    def real(self) -> 'float': ...
    @property
    def imag(self) -> 'float': ...
    def conjugate(self) -> 'float': ...

    def __add__(self, x: 'float') -> 'float': ...
    def __sub__(self, x: 'float') -> 'float': ...
    def __mul__(self, x: 'float') -> 'float': ...
    def __floordiv__(self, x: 'float') -> 'float': ...
    def __truediv__(self, x: 'float') -> 'float': ...
    def __mod__(self, x: 'float') -> 'float': ...
    # def __divmod__(self, x: 'float') -> Tuple['float', 'float']: ...
    def __pow__(self, x: 'float') -> 'float': ...  # In Python 3, returns complex if self is negative and x is not whole
    def __radd__(self, x: 'float') -> 'float': ...
    def __rsub__(self, x: 'float') -> 'float': ...
    def __rmul__(self, x: 'float') -> 'float': ...
    def __rfloordiv__(self, x: 'float') -> 'float': ...
    def __rtruediv__(self, x: 'float') -> 'float': ...
    def __rmod__(self, x: 'float') -> 'float': ...
    # def __rdivmod__(self, x: 'float') -> Tuple['float', 'float']: ...
    def __rpow__(self, x: 'float') -> 'float': ...
    # def __getnewargs__(self) -> Tuple['float']: ...
    def __trunc__(self) -> int: ...
    # @overload
    # def __round__(self, ndigits: None = ...) -> int: ...
    # @overload
    # def __round__(self, ndigits: int) -> 'float': ...

    def __eq__(self, x: object) -> bool: ...
    def __ne__(self, x: object) -> bool: ...
    def __lt__(self, x: 'float') -> bool: ...
    def __le__(self, x: 'float') -> bool: ...
    def __gt__(self, x: 'float') -> bool: ...
    def __ge__(self, x: 'float') -> bool: ...
    def __neg__(self) -> 'float': ...
    def __pos__(self) -> 'float': ...

    def __str__(self) -> 'str': ...
    def __int__(self) -> int: ...
    def __float__(self) -> 'float': ...
    def __abs__(self) -> 'float': ...
    def __hash__(self) -> int: ...
    def __bool__(self) -> bool: ...


# class str(Sequence[str], _str_base):
# noinspection PyPep8Naming,PyShadowingBuiltins
class str:
    # SWIFT_WRAPPER.str: ExpressibleByStringLiteral
    # SWIFT_WRAPPER.str: CPython

    # @not-overload
    # def __init__(self, o: object) -> None: ...
    # @not-overload
    # def __init__(self, o: bytes, encoding: 'str' = 'utf-8', errors: 'str' = 'strict'): ...

    def capitalize(self) -> 'str': ...
    def casefold(self) -> 'str': ...
    def center(self, width: int, fillchar: 'str') -> 'str': ...
    def count(self, x: Text, __start: int = 0, __end: int = -1) -> int: ...
    # def encode(self, encoding: Text = ..., errors: Text = ...) -> bytes: ...
    # def endswith(self, suffix: Union[Text, Tuple[Text, ...]], start: Optional[int] = None, end: Optional[int] = None) -> bool: ...
    def expandtabs(self, tabsize: int) -> 'str': ...
    def find(self, sub: Text, __start: int = 0, __end: int = -1) -> int: ...
    # def format(self, *args: object, **kwargs: object) -> 'str': ...
    # def format_map(self, map: Mapping['str', Any]) -> 'str': ...
    def index(self, sub: Text, __start: int = 0, __end: int = -1) -> int: ...
    def isalnum(self) -> bool: ...
    def isalpha(self) -> bool: ...
    def isdecimal(self) -> bool: ...
    def isdigit(self) -> bool: ...
    def isidentifier(self) -> bool: ...
    def islower(self) -> bool: ...
    def isnumeric(self) -> bool: ...
    def isprintable(self) -> bool: ...
    def isspace(self) -> bool: ...
    def istitle(self) -> bool: ...
    def isupper(self) -> bool: ...
    def join(self, iterable: 'List[str]') -> 'str': ...
    def ljust(self, width: int, fillchar: Optional['str'] = None) -> 'str': ...
    def lower(self) -> 'str': ...
    def lstrip(self, chars: Optional['str'] = None) -> 'str': ...
    # def partition(self, sep: 'str') -> Tuple['str', 'str', 'str']: ...
    def replace(self, old: 'str', new: 'str', count: int = -1) -> 'str': ...
    def rfind(self, sub: Text, __start: int = 0, __end: int = -1) -> int: ...
    def rindex(self, sub: Text, __start: int = 0, __end: int = -1) -> int: ...
    def rjust(self, width: int, fillchar: Optional['str'] = None) -> 'str': ...
    # def rpartition(self, sep: 'str') -> Tuple['str', 'str', 'str']: ...
    # def rsplit(self, sep: Optional['str'] = ..., maxsplit: int = ...) -> List['str']: ...
    def rstrip(self, chars: Optional['str'] = ...) -> 'str': ...
    def split(self, sep: Optional['str'] = None, maxsplit: int = -1) -> 'List[str]': ...
    # def splitlines(self, keepends: bool = ...) -> List['str']: ...
    # def startswith(self, prefix: Union[Text, Tuple[Text, ...]], start: Optional[int] = ...,
    #                end: Optional[int] = ...) -> bool: ...
    def strip(self, chars: Optional['str'] = None) -> 'str': ...
    def swapcase(self) -> 'str': ...
    def title(self) -> 'str': ...
    # def translate(self, table: Union[Mapping[int, Union[int, 'str', None]], Sequence[Union[int, 'str', None]]]) -> 'str': ...
    def upper(self) -> 'str': ...
    def zfill(self, width: int) -> 'str': ...
    # @staticmethod
    # @overload
    # def maketrans(x: Union[Dict[int, T], Dict['str', T], Dict[Union['str', int], T]]) -> Dict[int, T]: ...
    # @staticmethod
    # @overload
    # def maketrans(x: 'str', y: 'str', z: 'str' = ...) -> Dict[int, Union[int, None]]: ...

    def __add__(self, s: 'str') -> 'str': ...
    # Incompatible with Sequence.__contains__
    def __contains__(self, o: Union['str', Text]) -> bool: ...  # type: ignore
    def __eq__(self, x: object) -> bool: ...
    def __ge__(self, x: Text) -> bool: ...
    # def __getitem__(self, i: Union[int, slice]) -> 'str': ...
    def __getitem__(self, i: int) -> 'str': ...
    def __gt__(self, x: Text) -> bool: ...
    def __hash__(self) -> int: ...
    # def __iter__(self) -> Iterator['str']: ...
    def __le__(self, x: Text) -> bool: ...
    def __len__(self) -> int: ...
    def __lt__(self, x: Text) -> bool: ...
    def __mod__(self, x: Any) -> 'str': ...
    def __mul__(self, n: int) -> 'str': ...
    def __ne__(self, x: object) -> bool: ...
    def __repr__(self) -> 'str': ...
    def __rmul__(self, n: int) -> 'str': ...
    def __str__(self) -> 'str': ...
    # def __getnewargs__(self) -> Tuple['str']: ...


# # noinspection PyPep8Naming
# class bool(int):
#     # SWIFT_WRAPPER.float: ExpressibleByBooleanLiteral
#     # SWIFT_WRAPPER.float: CPython
#     # def __init__(self, o: object = ...): ...
#     @overload
#     def __and__(self, x: bool) -> bool: ...
#     @overload
#     def __and__(self, x: int) -> int: ...
#     @overload
#     def __or__(self, x: bool) -> bool: ...
#     @overload
#     def __or__(self, x: int) -> int: ...
#     @overload
#     def __xor__(self, x: bool) -> bool: ...
#     @overload
#     def __xor__(self, x: int) -> int: ...
#     @overload
#     def __rand__(self, x: bool) -> bool: ...
#     @overload
#     def __rand__(self, x: int) -> int: ...
#     @overload
#     def __ror__(self, x: bool) -> bool: ...
#     @overload
#     def __ror__(self, x: int) -> int: ...
#     @overload
#     def __rxor__(self, x: bool) -> bool: ...
#     @overload
#     def __rxor__(self, x: int) -> int: ...
#     # def __getnewargs__(self) -> Tuple[int]: ...


T = TypeVar('T')


# class list(MutableSequence[T], Generic[T]):
class List(Generic[T]):
    # SWIFT_WRAPPER.float: ExpressibleByArrayLiteral
    # SWIFT_WRAPPER.float: CPython
    # @not-overload
    def __init__(self): ...
    # @overload
    # def __init__(self, iterable: Iterable[T]) -> None: ...
    def clear(self) -> None: ...
    def copy(self) -> 'List[T]': ...
    def append(self, obj: T) -> None: ...
    def extend(self, iterable: 'List[T]') -> None: ...
    def pop(self, index: int = -1) -> T: ...
    def index(self, obj: T, start: int = 0, stop: int = -1) -> int: ...
    def count(self, obj: T) -> int: ...
    def insert(self, index: int, obj: T) -> None: ...
    def remove(self, obj: T) -> None: ...
    def reverse(self) -> None: ...
    # def sort(self, *, key: Optional[Callable[[T], Any]] = ..., reverse: bool = ...) -> None: ...

    def __len__(self) -> int: ...
    def __iter__(self) -> Iterator[T]: ...
    def __str__(self) -> str: ...
    def __hash__(self) -> int: ...
    # @not-overload
    def __getitem__(self, i: int) -> T: ...
    # @overload
    # def __getitem__(self, s: slice) -> 'List[T]': ...
    # @not-overload
    def __setitem__(self, i: int, o: T) -> None: ...
    # @overload
    # def __setitem__(self, s: slice, o: 'List[T]') -> None: ...
    def __delitem__(self, i: Union[int, slice]) -> None: ...
    def __add__(self, x: 'List[T]') -> 'List[T]': ...
    # def __iadd__(self: _S, x: Iterable[T]) -> _S: ...
    def __iadd__(self, x: 'List[T]'): ...
    def __mul__(self, n: int) -> 'List[T]': ...
    def __rmul__(self, n: int) -> 'List[T]': ...
    def __imul__(self, n: int): ...
    def __contains__(self, o: object) -> bool: ...
    # def __reversed__(self) -> Iterator[T]: ...
    def __gt__(self, x: 'List[T]') -> bool: ...
    def __ge__(self, x: 'List[T]') -> bool: ...
    def __lt__(self, x: 'List[T]') -> bool: ...
    def __le__(self, x: 'List[T]') -> bool: ...
